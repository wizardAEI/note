<!--
 * @Date: 2022-08-27 00:55:20
 * @LastEditors: aei(imaei@foxmail.com)
 * @LastEditTime: 2023-02-20 08:32:55
 * @FilePath: \2-后端\1-go\2-框架学习笔记.md
 * @description: 
-->
# 框架学习笔记

## gin框架

### 一个简单的gin程序

```go
package main

import (
	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()
	r.GET("/path", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"success": true,
		})
	})
	// uri挂载参数
	r.GET("/path/:id", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"success": true,
			"id":      c.Params,
		})
	})
	r.Run(":9000")
}
```

### gin.Default 和 gin.New 都做了什么

`gin.Default`返回一个`*Engine`类型，并且在创建指针时使用中间件：

```go
func Default() *Engine {
	debugPrintWARNINGDefault()
	engine := New()
	engine.Use(Logger(), Recovery())  // 使用中间件分别是日志和异常捕获
	return engine
}
```

而`gin.New`也是返回一个`*Engine`类型，但不会加上这些中间件，即不会由日志和有异常捕获的功能。



### path和query参数

```go
	r.GET("/path/:id", func(c *gin.Context) {
		id := c.Param("id")
		name := c.Query("name")
        // 如果没有page这个query，则默认取”1“
        page := c.DefaultQuery("page", "1")
		c.JSON(200, gin.H{
			"success": true,
			"id":      id,
			"name":    name,
		})
	})
```

此时访问`http://127.0.0.1:9000/path/123?name=a` 将会得到：

```json
{
    "id": "123",
    "name": "xiaoa",
    "success": true
}
```

如果想同时处理path和query，也可以使用`*`关键字：

```go
r.GET("/path/*all",handler）
```

#### 对path和query进行约束：

**使用`ShouldBindUri`对path进行约束：**

单独拎出一个model，进行校验：

```go
// 例如需要校验 /:id/:name 其中id需要为数字
// 定义结构体
type Product struct {
	ID   int    `uri:"id"`
	Name string `uri:"name"`
}

// 校验
productGroup := r.Group("/product")
productGroup.GET("/:id/:name", func(c *gin.Context) {
    var p Product
    err := c.ShouldBindUri(&p)
    if err != nil {
        c.JSON(400, gin.H{
            "msg": err,
        })
    } else {
        c.JSON(200, gin.H{
            "msg": "ok",
        })
    }
})
```

当我们id的path参数不是一个数字时，例如：`/product/xxx/apple`

则最终返回：

```json
{
    "msg": {
        "Func": "ParseInt",
        "Num": "xxx",
        "Err": {}
    }
}
```

**使用`ShouldBindQuery`对query进行约束：**

和上面校验path类似的方法类似，例如上面的id和name时在query中传递的，则model可以这么写：

```go
type Product struct {
	ID   int    `form:"id"`
	Name string `form:"name"`
}
```

### 获取form参数，json参数和设置默认参数

post请求可以使用`PostForm`去获取body中传递过来的`form-data`类型的参数，我们也可以使用`DefaultPostForm`来设置默认参数，这样即使没有传递表单信息也可以生成默认的值：

```go
// 一个post的handler
func accountAdd(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"val": c.DefaultPostForm("val", "a"),
	})
}
```

如果前端发送过来的body信息是json类型的，那我们可以先对JSON数据进行解析，再去使用其值:

```go
// 定义一个model
type AddProductModel struct {
	Val  string `json:"val" binding:"required,min=1,max=8"`// 这里还可以限制字数
	Size int    `json:"size" binding:"required"`
}
```

在一个post请求中使用它：

```go
func accountAdd(c *gin.Context) {
	var data model.AddProductModel
	err := c.ShouldBindJSON(&data)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"msg": "invalid json",
		})
		return
	}
	c.JSON(http.StatusOK, gin.H{
		"data": data,
		"msg":  "ok",
	})
}
```

这样如果给出的json数据不合法或者缺失，我么都会返回400，只有符合结构体要求时才会200。

### gin Group功能

[gin框架 路由分组 - 编程宝库 (codebaoku.com)](http://www.codebaoku.com/gin/gin-router-group.html)



### 中间件

使用`Use`方法加载中间件：

```go
func CustomMiddleWare(c *gin.Context) {
	fmt.Println("1")
	c.Next()
	fmt.Println("2")
}

func main() {
	r := gin.Default()
	r.Use(CustomMiddleWare)
	r.GET("/product", func(c *gin.Context) {
		fmt.Println("3")
		c.JSON(http.StatusOK, gin.H{
			"msg": "ok",
		})
	})
	err := r.Run(":9000")
	if err != nil {
		return
	}
}

// 按顺序输出 1 3 2
```

#### 退出（中断）中间件

使用`Abort`方法中断中间件，不再执行后面的方法：

```
func CustomMiddleWare(c *gin.Context) {
	fmt.Println("1")
	if ... {
		c.Abort()
	}
	c.Next()
	fmt.Println("2")
}
```

### 路由和中间件

[(31条消息) Gin 路由以及中间件_星汉空兮的博客-CSDN博客](https://blog.csdn.net/WU2629409421perfect/article/details/107981683)

### 协程运行`r.Run`

对于`r.Run`来说，为了防止其运行完整个程序就结束了，我们可以运行一个协程去执行`r.Run`，同时在主协程中监听一些常见事件，确保在程序结束时可以执行一些其他善后工作：

```go
// 使用另外的协程执行Run函数
go func() {
		err := r.Run(":9000")
		if err != nil {
			return
		}
	}()
exit := make(chan os.Signal)
// 监听键盘ctrl+c和kill函数，当出现响应信号时向通道内发送数据
signal.Notify(exit, syscall.SIGINT, syscall.SIGTERM)
<-exit
// 执行善后工作
fmt.Println("程序结束")
```



## ORM

ORM（Object Relation Mapping）通过实例化对象完成对关系型数据库的操作。



### 启动一个myssql容器

```yml
version: '3.1'

services:
  db:
    image: mysql
    command: --default-authentication-plugin=mysql_native_password
    ports:
      - "3308:3306"
    volumes:
      - ./data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: 123456
```

启动命令：`docker-compose up`

### 连接数据库

连接一个mysql数据库：

```go
package main

import (
	"fmt"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

func main() {
	dsn := "root:123456@tcp(127.0.0.1:3308)/gin_learn?charset=utf8mb4&parseTime=True&loc=Local"
	_, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		panic(err)
	}
	fmt.Println("连接成功...")
}
```

解释以下其中的dsn字符串：

`用户名:密码@tcp(ip地址:端口)/数据库名称?charset=utf8mb4&parseTime=True&loc=Local`

### logger

[Logger | GORM - The fantastic ORM library for Golang, aims to be developer friendly.](https://gorm.io/zh_CN/docs/logger.html)

### gorm 设置表名

通过给结构体定义`TableName`方法，可以指定结构体的表名：

```go
// Product 声明一个商品模型
type Product struct {
	gorm.Model
	Code  string
	Price uint
}
// 指定商品模型的表名
func (p Product) TableName() string {
    return "product"
}
```

### gorm 模型迁移

使用`AutoMigrate`函数可以将做好的模型迁移到数据库，如果当前数据库不具有该模型，则生成一个表。

```go
// Product 声明一个商品模型
type Product struct {
	gorm.Model
	Code  string
	Price uint
}

err = db.AutoMigrate(&model.Product{})
```

这里根据模型生成的表结构中，列都是小写下划线形式的，例如`code`,`create_at`

### gorm 增删改查

我们将连接数据库生成的db作为包级别的首先声明：

```go
var db *gorm.DB
```

然后定义init函数来初始化数据库：

```go
func init() {
	newLogger := logger.New(
		log.New(os.Stdout, "\r\n", log.LstdFlags), // io writer（日志输出的目标，前缀和日志包含的内容——译者注）
		logger.Config{
			SlowThreshold:             time.Second, // 慢 SQL 阈值
			LogLevel:                  logger.Info, // 日志级别
			IgnoreRecordNotFoundError: true,        // 忽略ErrRecordNotFound（记录未找到）错误
			Colorful:                  true,        // 彩色打印
		},
	)
	dsn := "root:123456@tcp(127.0.0.1:3308)/gin_learn?charset=utf8mb4&parseTime=True&loc=Local"
	var err error
	db, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: newLogger,
	})
	if err != nil {
		panic(err)
	}
	fmt.Println("连接成功...")
}
```

init函数go语言会自动执行，我们不需要引用它。

在`main`函数中,我们执行增删改查的动作：

```go
func main() {
	// 增
	//db.Create(&model.Product{})

	var p model.Product

	// 查单个
	//db.Find(&p, "code = ?", "D42")
	//fmt.Println(p.Price)

	// 查多个
	//var products []model.Product
	//result := db.Find(&products, "code = ?", "D42")
	//fmt.Println(result.RowsAffected)
	//fmt.Println(products[0].CreatedAt)
	//fmt.Println(products[1].CreatedAt)

	// 更新一列
	//db.Model(&p).Where("id = ?", "1").Update("price", 300)

	// 更新多列
	//db.Model(&p).Where("id = ?", "1").Updates(model.Product{
	//	Price: 400,
	//	Code:  "D43",
	//})

	// 更新零值 由于gorm处于保护机制，在更新多列时并不会更新零值，我们需要使用map去更新0值
	//db.Model(&p).Where("id = ?", "1").Updates(map[string]interface{}{
	//	"Code":  "",
	//	"Price": 0,
	//})

	// 删除
	// 软删除 当模型具有deleted_at字段时 gorm会通过设置deleted_at字段的方法来进行软删除删除
	// db.Delete(&p, 1) // 进行删除后gorm后，其实执行的是 UPDATE `products` SET `deleted_at`='2022-12-30 20:14:35.437' 操作

	db.Find(&p, "id = ?", "2")
	fmt.Println(p.Code)
}
```

具体实例：

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230121001711.png)

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230121001735.png)

**tip:**查询出来的记录，如果该记录的某一列为null，那么会根据该列在gorm定义的模型中选取默认值作为该列值。例如User模型中，height为int型，在数据库中没有定义为null，则返回值为0。

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230121003157.png)

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230121003209.png)

### gorm 更新零值的第二种方式

在上面的代码中，我们可以使用`map[string]interface{}{...}`更新零值，现在我们也可以使用`sql.NullString`这样的方式去更新零值或空值：

空字符串：sql.NullString

数字0：sql.NullInt32

例子：

```go
// 修改模型 Product
type Product struct {
	gorm.Model
	Code  sql.NullString
	Price uint
}
// 增加记录：
func main() {
	p := &model.Product{
		Code: sql.NullString{
			Valid: false,
		},
	}
	db.Create(p)  
}
```

这样增加的记录，Code是null。（并非是空字符串而是直接null）

我们更新记录使得该列不再null，而是空字符串：

```go
func main() {
	var p model.Product
	db.Model(&p).Where("id = ?", 4).Update("code", sql.NullString{
		Valid:  true,
		String: "",
	})
	fmt.Println(p.Code.String) // ""
}
```

### gorm 模型定义

我们使用gorm时，尽量遵守其模型定义规范，这样使用gorm会方便很多：

[模型定义 | GORM - The fantastic ORM library for Golang, aims to be developer friendly.](https://gorm.io/zh_CN/docs/models.html)

例子：

```go
// Food 声明一个食物模型
type Food struct {
	FoodId    uint   `gorm:"primaryKey"`
	Name      string `gorm:"column:food_name;type:varchar(64);index:idx_food_name,unique"`
	DeletedAt gorm.DeletedAt
}
```

其中的FoodId作为主键；Name作为索引，在数据库中的列名为`food_name`，unique代表将列定义为唯一键；DeleteAt为`gorm.DeletedAt`类型可以用作软删除。

### gorm 批量添加

方案1：

创建一个model切片，使用`db.Create`添加：

```go
foods := []model.Food{
    {
        Name: "feed",
    },
    {
        Name: "banana",
    },
    {
        Name: "orange",
    },
}
res := db.Create(foods) // 注意这里不使用指针，因为切片本身就是引用类型
```

方案2：

```go
// 批量添加 每次添加2条
db.CreateInBatches(foods, 2)
```

这里的批量添加会每次向数据库中添加两条记录，如果一共有3条记录，那么会添加两次：

```sql
INSERT INTO `foods` (`food_name`,`deleted_at`) VALUES ('feed',NULL),('banana',NULL)

INSERT INTO `foods` (`food_name`,`deleted_at`) VALUES ('orange',NULL)
```

方案3：

```go
// 使用map添加
db.Model(&model.Food{}).Create([]map[string]interface{}{
    {
        "Name": "apple",
    },
    {
        "Name": "orange",
    },
    {
        "Name": "grape",
    },
})
```

使用map这种方式批量添加只会添加定义的列和主键，其他的列不会使用默认值而是直接为NULL

### gorm 局部更新 (+更新列零值的第三种方式)

gorm在使用`Updates`方法时，gorm会自动忽略没有赋值或者赋值为零值的属性。当我们想只局部更新某些属性时，可以使用`Select`方法选择部分属性进行更新：

```go
func main() {
	p := &model.Product{}
	db.First(&p, "code = ?", "D42").Select("price").Updates(model.Product{
		Code: "xxx",
		Price: 200,
	})
}
```

当我们确定好了更新范围时，即使后面的更新函数中写明了要更新其他列，sql语句中也只会更新范围内的列：

```sql
UPDATE `products` SET `updated_at`='2023-01-01 15:34:57.693',`price`=200 WHERE code = 'D42' AND `products`.`deleted_at` IS NULL AND `id` = 2 ORDER BY `products`.`id` LIMIT 1
```

除了使用`Select`选择之外，还可以使用`Omit`进行忽略操作。

### gorm 添加依赖的数据

当两个模型之间存在依赖的时候，我们可以利用gorm来建立其之间的依赖：

例如我们建立员工表和公司表，假设员工和公司都是一一对应的,有一个员工就有一个公司（极端情况，勿带入实际）：

```go
// 模型 这里的每一个Employer都对应一个确定的公司
type Employer struct {
	gorm.Model
	Name      string
	CompanyID int
	Company   Company
}

type Company struct {
	gorm.Model
	Name string
}
```

```go
// 插入数据时
company1 := model.Company{
    Name: "xx公司",
}
employ1 := model.Employer{
    Name:    "小王",
    Company: company1, // 这里我们直接拷贝company1
}
db.Create(&employ1) // 在插入employ1记录时，会先自动添加一个Company记录，根据company1填写相关字段
```

最终效果：

```
// 公司表
id
2	2023-01-14 01:24:11.441	2023-01-14 01:24:11.441		xx公司
// 人员表
id                                                          company_id
1	2023-01-14 01:24:11.446	2023-01-14 01:24:11.446		小王	   2
```

#### 一对多的关联添加

继续上面的例子，我们继续建立信用卡表，员工和信用卡的关系是一对多的关系：

```go
// model
type Employer struct {
	gorm.Model
	Name       string
	CompanyID  int
	Company    Company
	CreditCard []CreditCard `gorm:"foreignKey:employer_id;references:id"` // 使用切片来表示一对多的关系
}

type CreditCard struct {
	gorm.Model
	Number     string
	EmployerId uint
}
```

我们添加的时候可以这样去添加：

```go
employ := model.Employer{}
db.First(&employ, 1) //找到id为1的员工记录
for i := 0; i < 5; i++ {
    id := i + 1
    c := model.CreditCard{
        Number:     "信用卡" + strconv.Itoa(id+1),
        EmployerId: employ.ID,
    }
    db.Create(&c)
}
```

这样我们对一对多的员工记录进行查询时，可以预加载其中的所有信用卡记录：

```
	employ := model.Employer{}
	db.Preload("CreditCards").First(&employ, 1)
	fmt.Println(employ.ID)
	fmt.Println(employ.CreditCards) // 因为预加载，虽然我们查询的是员工表，但实际上有两条查询语句，最终可以查询到所有信用卡记录
```

并且gorm在处理这样一对一多的场景，都会在创建表时添加上外键。详情：[Belongs To | GORM - The fantastic ORM library for Golang, aims to be developer friendly.](https://gorm.io/zh_CN/docs/belongs_to.html)

### gorm 预加载

[预加载 | GORM - The fantastic ORM library for Golang, aims to be developer friendly.](https://gorm.io/zh_CN/docs/preload.html)

### gorm 解决冲突

使用`clause.OnConflict`来解决添加冲突：

```go
p := &Product{ID: 1}
db.Clauses(clause.OnConflict{DoNothing: true}).Create(&p) // 如果添加过程中出现重复主键等冲突情况，由于DoNothing: true，出现冲突后gorm会什么都不做并且中断操作。
```

### gorm tag

```go
`gorm: "primarykey"` 主键
`gorm: "column: code"` 列名
`gorm: "default: 18"` 默认值
`gorm: "type: varchar(8)"` 数据在数据库中的类型
`gorm: "foreignKey:identity;references:user_identity"` 将该属性锁对应的结构体中的identity作为外键，和当前整体对象的user_identity属性做映射
```



### gorm 非链式调用

gorm是支持非链式调用的，并且能保证达到链式调用的效果：

```go
	tx = Db.Model(&SubmitBasic{})
	if pid != "" {
		tx.Where("problem_identity = ?", pid)
	}
	if uid != "" {
		tx.Where("user_identity = ?", uid)
	}
	if status != 0 {
		tx.Where("status = ?", status)
	}
	return tx
```

这样写，每个分支中的查询都会影响tx，但是不用写成链式调用。

### gorm 事务

这里说明的使用tx而不使用db，是因为gorm底层调用mysql是使用**链接池**的方式，这里使用的tx就是固化下来的一个链接。由于我们需要保证一个事务从头到尾使用一个链接，所以需要使用tx。

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230121003110.png)

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230121003126.png)



### gorm hook

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230121003956.png)

### gorm性能提高

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230121004351.png)

此外，还可以在DSN中加入interpolateParams=false这一设置，默认为true是为了防止传统字符集下sql注入的问题，但现在使用UTF-8编码的情况下，已经不需要这一功能了，将其设为false性能更高。

### grom生态

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230121004256.png)

## Kitex

[快速开始 | Kitex](https://www.cloudwego.io/zh/docs/kitex/getting-started/)

kitex是字节开源的一个RPC框架

### 注册与发现

使用注册与发现中心，可以让我们的RPC框架在调用不同服务时更加直观和有效率，并且性能上也会有所提升。

使用ETCD注册与发现实例：[registry-etcd/example at main · kitex-contrib/registry-etcd (github.com)](https://github.com/kitex-contrib/registry-etcd/tree/main/example)

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230121095814.png)

## Hertz

[快速开始 | Hertz](https://www.cloudwego.io/zh/docs/hertz/getting-started/)

![image-20230121100104908](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230121100104908.png)



## 常用其他框架

### net/http http状态码

`"net/http"`为我们提供了很多更可读的状态码简称，比如：

```go
http.StatusOK // 200
http.StatusCreated  // 201
http.StatusAccepted // 202
http.StatusBadRequest  // 400
```

### jwt-go

安装：

```shell
go get github.com/dgrijalva/jwt-go
```

使用：

```go
package service

import (
	"errors"
	"github.com/dgrijalva/jwt-go"
	"time"
)

type UserClaims struct {
	Name   string `json:"name"`
	Expire int    `json:"expire"`
	jwt.StandardClaims
}

var key = "asdsaf"

// ParseToken 解析token
func ParseToken(str string) (UserClaims, error) {
	c := new(UserClaims)
	token, err := jwt.ParseWithClaims(str, c, func(token *jwt.Token) (interface{}, error) {
		return []byte(key), nil
	})
	if token.Valid != true {
		return *c, errors.New("token不合法")
	}
	return *c, err
}

// GenerateToken 生成7天的token
func GenerateToken(name string) (str string) {
	c := &UserClaims{
		Name:   name,
		Expire: int(604800 + time.Now().Unix()), // 7天
	}
	claims := jwt.NewWithClaims(jwt.SigningMethodHS256, c)
	// 根据自定义key生成tokenString
	token, _ = claims.SignedString([]byte(key))
	return
}

```



### go-redis

[(30条消息) Window下Redis的安装和部署详细图文教程（Redis的安装和可视化工具的使用）_windows下载安装redis_明金同学的博客-CSDN博客](https://blog.csdn.net/weixin_44893902/article/details/123087435)

[redis/go-redis: Type-safe Redis client for Golang (github.com)](https://github.com/redis/go-redis)

### go.uuid

生成唯一标识库 go get github.com/gofrs/uuid

```go
package main

import (
	"log"s
	"github.com/gofrs/uuid"
)

// Create a Version 4 UUID, panicking on error.
// Use this form to initialize package-level variables.
var u1 = uuid.Must(uuid.NewV4())

func main() {
	// Create a Version 4 UUID.
	u2, err := uuid.NewV4()
	if err != nil {
		log.Fatalf("failed to generate UUID: %v", err)
	}
	log.Printf("generated Version 4 UUID %v", u2.String()) // uuid长度36位

	// Parse a UUID from a string.
	s := "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
	u3, err := uuid.FromString(s)
	if err != nil {
		log.Fatalf("failed to parse UUID %q: %v", s, err)
	}
	log.Printf("successfully parsed UUID %v", u3)
}
```

### md5

```go
package main

import (
	"crypto/md5"
	"fmt"
)

func MD5(str string) string {
	data := []byte(str) //切片
	has := md5.Sum(data)
	md5str := fmt.Sprintf("%x", has) //将[]byte转成16进制
	return md5str
}


func main(){
	
	str := MD5("hello")

	fmt.Println(str)
	
}
```

### pprof

性能调优的核心是性能瓶颈的分析，对于 Go 应用程序，最方便的就是 pprof 工具

- ##### pprof 功能说明

  - pprof 是用于可视化和分析性能分析数据的工具
  - 可以知道应用在什么地方耗费了多少 CPU、memory 等运行指标 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b91cd175657042f5ab0430cbc8784172~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

- #### pprof 实践

  - 实际分析排查过程
    - 排查 CPU 问题
      - 命令行分析
        - go tool pprof "[http://localhost:6060/debug/pprof/profile?seconds=10](https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A6060%2Fdebug%2Fpprof%2Fprofile%3Fseconds%3D10)"
      - top 命令
      - list 命令
      - 熟悉 web 页面分析
      - 调用关系图，火焰图
      - go tool pprof -http=:8080 "[http://localhost:6060/debug/pprof/cpu](https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A6060%2Fdebug%2Fpprof%2Fcpu)"
    - 排查堆内存问题
      - go tool pprof -http=:8080 "[http://localhost:6060/debug/pprof/heap](https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A6060%2Fdebug%2Fpprof%2Fheap)"
    - 排查协程问题
      - go tool pprof -http=:8080 "[http://localhost:6060/debug/pprof/goroutine](https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A6060%2Fdebug%2Fpprof%2Fgoroutine)"
    - 排查锁问题
      - go tool pprof -http=:8080 "[http://localhost:6060/debug/pprof/mutex](https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A6060%2Fdebug%2Fpprof%2Fmutex)"
    - 排查阻塞问题
      - go tool pprof -http=:8080 "[http://localhost:6060/debug/pprof/block](https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A6060%2Fdebug%2Fpprof%2Fblock)"

- ##### pprof 的采样过程和原理

  - CPU 采样
  - 堆内存采样
  - 协程和系统线程采样
  - 阻塞操作和锁竞争采样

#### 性能调优案例

- ##### 基本概念

  - 服务：能单独部署，承载一定功能的程序
  - 依赖：Service A 的功能实现依赖 Service B 的响应结果，称为 Service A 依赖 Service B
  - 调用链路：能支持一个接口请求的相关服务集合及其相互之间的依赖关系
  - 基础库：公共的工具包、中间件

- ##### 业务优化

  - 流程
    - 建立服务性能评估手段
    - 分析性能数据，定位性能瓶颈
    - 重点优化项改造
    - 优化效果验证
  - 建立压测评估链路
    - 服务性能评估
    - 构造请求流量
    - 压测范围
    - 性能数据采集
  - 分析性能火焰图，定位性能瓶颈
    - pprof 火焰图
  - 重点优化项分析
    - 规范组件库使用
    - 高并发场景优化
    - 增加代码检查规则避免增量劣化出现
    - 优化正确性验证
  - 上线验证评估
    - 逐步放量，避免出现问题
  - 进一步优化，服务整体链路分析
    - 规范上游服务调用接口，明确场景需求
    - 分析业务流程，通过业务流程优化提升服务性能

- ##### 基础库优化

  - 适应范围更广，覆盖更多服务
  - AB 实验 SDK 的优化
    - 分析基础库核心逻辑和性能瓶颈
    - 完善改造方案，按需获取，序列化协议优化
    - 内部压测验证
    - 推广业务服务落地验证

- ##### Go 语言优化

  - 适应范围最广，Go 服务都有收益
  - 优化方式
    - 优化内存分配策略
    - 优化代码编译流程，生成更高效的程序
    - 内部压测验证
    - 推广业务服务落地验证

## 
