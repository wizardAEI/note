## Rpc框架

### RPC 基本概念

引例（函数调用）：

```go
func main() {
	var a = 3
    var b = 3
    sum := add(a, b)
}
func add (a, b int) int {
	returm a + b
}
```

上述的本地函数的调用，直接通过主函数中调用工具函数就行了。

然而我们 RPC（ Remote Procedure Calls ）是远程调用函数，所以相较于上面的本地函数调用，我们需要解决以下几个问题：

1. 函数映射问题：如何告诉一个服务如何正确的调用另一个服务的指定函数。
2. 数据转换成字节流：我们的参数和返回数据都需要转换成字节流在两个服务之间进行通讯（因为默认两个服务在不同的内存和进程，不能通过内存共享，数据入栈等方式进行数据直接传递）。
3. 网络传输：对于两个服务来说，传输数据往往是通过网络进行传递的。

现代的 RPC 框架，在不断探索之中已经很好的解决了上面的问题，在讨论现代框架之前，我们先了解一些相关的**概念**：

1. IDL ：IDL 通过一种中立的方式来描述接口，使得在不同平台上运行的对象和不同语言编写的程序可以相互通信；
2. 生成代码：通过编译器工具把 IDL 文件转换成语言对应的静态库；
3. 编解码：从内从中表示到字节序列的转换成为编码，反之为解码，也常叫做序列化和反序列化；
4. 通信协议：规范了数据在网络中的传输内容和格式。出必须的请求/相应书之外，通常还包括额外的元数据；
5. 网络传输：通常基于成熟的网络库走 TCP/UDP 传输。

### RPC 分层设计

首先，RPC 一般会有两个**对称**的端，被称为调用端（ Client端 ）和非调用端（ Server端 ），服务实现写在非调用端中，而调用段则用来使用服务。

接下来的分层设计中，不强调是哪一个端，默认是对称设计的。

1. **编解码层**

   在编解码层，从上到下分别为：业务逻辑层（ Code层，用户编写 ）；生成代码（ IDL生成 ）；编解码层；协议层；网络通讯层（用来在 Client 和 Server 端通讯 ）

   ![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230214195636.png)

   框架的编解码层是用来定义 RPC 框架的数据格式的。该数据格式应该具有**前后兼容性**，**通用性**，**性能**三个方面考虑。现代框架中，一般会使用编程语言内建的格式或者比较通用的二进制编码（如 BinaryProtocol，Protobuf 等 ）。

   以 BinaryProtocol 为例，其为 Thrift 的 IDL 文件生成， 书写 IDL 时，数据结构由三部分组成，分别为指定类型的 Tag，指定长度的 Length，指定编码值的 Value。进而生成字节流（即 BinaryProtocol ）。

   ![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230214200746.png)

   将数据生成字节流后，我们需要为其加入一些元数据，补位，结束符等一些标识，好用来进行网络通讯。这一步就是协议层进行的。

   ![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230214201912.png)

   ![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230214201830.png)

   RPC 的网络通讯使用 Sockets API 为底层的网络库进行在接收端和被接收端之间通讯：

   ![image-20230214202355197](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230214202355197.png)

在进行实际的微服务开发时，我们需要一些指标来权衡该框架以及该框架下的业务是否是可用的，优秀的。一般来说，我们需要关注一个微服务的安全性，稳定性，可扩展性，兼容性，和高性能等。这里结合日常开发时我们使用到的一些框架基本上都是带有这些功能的，所以这里更加关注的是实际开发中，对于开发者来说更应该注意的内容。即在开发中，我们应该去利用框架带来的功能去实现什么必要的微服务特征来保证我们的微服务是更好的。

### RPC 开发关键指标

#### 稳定性

降级措施：

- 熔断：当某一个服务出现问题的时候，其他服务访问该服务时快速返回结果。避免等待，出错等防止服务雪崩；
- 限流：防止大流量将服务压垮；
- 超时控制：避免浪费资源在不可用节点上。

提高请求成功率：

- 负载均衡：利用负载均衡分配服务调用；
- 重试：调用不成功时，我们不直接返回错误，而是进行重试。例如我们设置次数为3，那么当我们第一次请求失败后，进行两次重试，都不成功再返回失败或错误；
- 长尾请求：一个服务的同一个请求有时候由于某些原因（例如网络抖动）相较于其他请求会时间很长，那么这种请求就是长尾请求（例如超过了99%的请求的时间）。为了防止这种请求带来的请求成功率降低，我们可以再请求时设定一个长尾请求超时时间（一般根据以前请求的记录来判断该时间设置为多少）来进行重试。当某个请求并没有出错，但是超过了该超时时间，那么我们发起重试去再次请求。

这些措施我们可以通过注册中间件的形式来融入进来。

#### 观测性

- Log：日志服务，用来记录服务运行情况；
- Metric：监控，通过面板来检测 QPS，延迟等；
- Tracing：链路追踪，对一个请求中的一系列服务调用进行追踪并观察其性能等；
- 框架内置的观测服务（如查看 cpu，memory）。

#### 高性能

目标：**高吞吐**，**低延时（最重要）**

手段：连接池，多路复用，高性能编解码协议，高性能网络库。

## Kitex

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/20230214233137.png)