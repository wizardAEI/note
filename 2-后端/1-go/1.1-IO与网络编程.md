## Go语言的文件接口

Go 语言有两个重要的接口，`io.Reader` 和 `io.Writer`

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}

type Writer interface {
	Write(p []byte) (n int, err error)
}
```

接口特点：

1. 面向接口，使用 Go 的 interface，隐式实现
2. 面向**字节流**处理，不对内容做假设

第三方库只要实现了接口就可以使用已有的各种文件设施。

###  标准 IO

标准库中 IO 设施根据用途可以分为以下三类：

- 数据生产和消费终端：如 `os.File`，`net.Conn`，`bytes.Buffer`
- 中间件，如`bufio`，`Reader`，`gzip.Reader`
- 工具库，操作`io.Reader`和`io.Writer`实现某种功能`ioutil`，`io.Copy`等

### 常见的文件操作：

- 读取文件：`content，err := os.ReadFile("urls.txt")`（小文件）

- 整存文件：`os.WriteFile("urls.txt", conetnt, 0644)`（小文件）

- 流式读取文件：

  ```go
  	f, err := os.Open("urls.txt")
  	if err != nil {
   		panic(err)
  	}
  	defer f.Close()
  	buf := make([]byte, 1024)
  	for {
        n, err := f.Read(buf)
  		if err != nil {
  			fmt.Println(err) // 读取完成后会是 EOF
  			break
  		}
      // 注意这里的 slice 操作，Read并不能保证可以填充满 buf
  		fmt.Println(string(buf[:n]))
  	}
  ```

  上述过程可以使用`io.Copy` 来简化操作：

  ```go
  func TestFIle(t *testing.T) {
  	f, _ := os.Open("urls.txt")
  	defer f.Close()
  	io.Copy(os.Stdout, f)
  }
  ```

  `io.Copy`接受一个 Writer 和一个 Reader ，将源复制到目标，并且是按默认的缓冲区32k循环操作的，不会将内容一次性全写入内存中,这样就能解决大文件的问题。

  当我们需要**自定义缓冲区大小**或者将中间的缓冲区**切换成高性能的`sync.Pool`** 时，也可以使用 `io.CopyBuffer`进行处理。

- 按行处理文件

  当文件内容比较多时，我们整读出来按回车来 split 不太合适，这个时候可以使用 scanner 来一行行的处理：

  ```go
  	f, _ := os.Open("urls.txt")
  	defer f.Close()
  	scanner := bufio.NewScanner(f)
  	for scanner.Scan() {
  		fmt.Println(scanner.Text())
  	}
  ```

- 内存文件

  这里的内存文件指的是只存在于内存中的文件而不是某个目录下的文件。例如，当我们进行接口测试的时候，有事需要 mock 一个文件出来传递给另外的函数去读取：

  ```go
  	// 创建一个内存文件
  	buf := bytes.Buffer{}
  	// 将字符串写入到内存文件中
  	buf.WriteString("hello world\nhello golang\n")
  	// 读取内存文件
  	scanner := bufio.NewScanner(&buf)
  	for scanner.Scan() {
  		fmt.Println(scanner.Text())
  	}
  ```

  当数据需要从远程拉取时，也可以通过 `bytes.Buffer` 接收返回（虽然有点没必要了）：

  ```go
  	buf := bytes.Buffer{}
  	res, _ := http.Get("https://picsum.photos/200/300")
  	res.Write(&buf)
  	scanner := bufio.NewScanner(&buf)
  	for scanner.Scan() {
  		fmt.Println(scanner.Text())
  	}
  ```

  或者使用`bytes.Buffer`模拟一个文件上传

  ```go
  buf := bytes.Buffer{} // mock a file
  ... // 填充数据
  res, err := http.Post("http://example.com/upload", "image/png", &buf)
  ```

- 随机 buffer 生成

  ```go
  	buf := make([]byte, 1024)
  	io.ReadFull(rand.Reader, buf)
  	io.Copy(os.Stdout, bytes.NewReader(buf))
  ```

- 生成一个空文件（所有位都是0）

  首先我们需要自定义一个结构体来实现 Read 方法，成为一个 Reader 接口类型

  ```go
  // 这里遍历拿到的切片并且填满0来实现所有字节对应的uint8为0，即8位都为0
  // 效果就是让来读取的 buf 拿到全是空数据的效果
  type zeroReader struct{}
  
  func (r zeroReader) Read(buf []byte) (int, error) {
  	for i := range buf {
  		buf[i] = 0
  	}
  	return len(buf), nil // error 始终不会返回 EOF
  }
  ```

  然后利用该结构体初始化一个文件

  ```go
  f, _ := os.Create("test.txt")
  defer f.Close()
  // 1MB
  io.Copy(f, io.LimitReader(zeroReader{}, 1024*1024))
  // limitReader 就是初始化一个有读取长度限制的 Reader，需要限制是因为我们自定义的 Reader 不会返回 EOF，每次都会填满 buf
  ```

- 格式化输入输出

  `fmt` 包的 `Fprint`, `Fprintf`, `Fscanf`可以用于所有类文件（实现了 Write 方法）的输入和输出。

  例如：

  ```go
  // 当前时间存入到 test.txt	
  f, _ := os.Create("test.txt")
  fmt.Fprintf(f, "%s", time.Now())
  
  // 将当前时间放到 http 的 writer 中返回
  func handle(w http.ResponseWriter, r *http.Request) {
  	fmt.Fprintf(w, "%s", time.Now())
  }
  ```

- bufio

  `bufio` 会将在io操作中较小的文件内容存入到缓冲区中，来避免多次小内容的读写，提高效率。

  例如我们需要多次小的读取和存储时来完成一个整体的读取和存储可以使用`bufio`

  ```go
  // 这里打开文件需要指定行为和权限：os.O_CREATE|os.O_RDWR打开或创建一个可读写的文件，0644文件拥有者可读写
  f, _ := os.OpenFile("test.txt", os.O_CREATE|os.O_RDWR, 0644)
  defer f.Close()
  w1 := bufio.NewWriter(f) // 默认建立时的缓存区大小是 4096 byte
  for i := 1; i <= 1000; i++ {
    w1.WriteString(fmt.Sprintf("%d:hello", i))
  }
  w1.Flush() // 注意一定要 Flush 强制刷新缓存区将缓存区数据存储到文件中，否则数据在可能会有一部分在缓存中没有写进去
  ```

- 多路派发和接收

  通过`MultiReader`（接收多个 Reader）和`MultiWriter`（接收多个 Writer），我们就可以实现将文件分别输出到多个地方，或者从多个地方同时读取并整合在一起：

  ```
  // 利用 MultiWriter 边输出边计算hash
  f, _ := os.Open("test.txt")
  defer f.Close()
  hash := sha256.New()
  w := io.MultiWriter(os.Stdout, hash)
  io.Copy(w, f)
  fmt.Printf("\n%x", hash.Sum(nil))
  ```

## Go 网络编程

### C10K 问题

C10K是一个术语，指的是能够同时处理10,000个并发连接的能力。和QPS不同，C10K强调的是并发。

### 网络模型

大体可以分为 （本地和远程）IO 需求和 CPU 计算需求。

在这种背景下，现代的网络编程框架解决办法通常有这几种：

#### 使用多线程阻塞 IO 模型（JAVA系）

这种形式会每个请求创建一个线程，线程中线性处理逻辑，第三方服务会在本线程堵塞，并发量大的时候线程个数会成为瓶颈。并且线程切换，创建也会带来很大的性能损耗。（线程切换大概3-20us，相比之下一级CPU缓存获取数据大概零点几纳秒，内存获取数据大概是几十到几百纳秒，向网络上发送 1kb 的数据大概是 3 us；同时一个线程栈占用大概1-2MB）

在种种背景下，多线程方案往往不能解决高并发服务。因为线程的切换和增加也会耗时，这会导致在提升并发的同时会造成时延也提升，综合下来整体**延迟变高**，吞吐量并不会增加甚至可能会下降。

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/7113275.png)

#### 单线程（IO）多路复用（例如 Redis6.0 之前和 Node 系）

本质是一种事件派发和回调。在单线程模型下第三方服务和 IO 操作进行异步处理（在另外的线程池中）并通过回调的方式返回（不会阻塞）。主服务一直在一个线程，不用考虑加锁。但是CPU密集处理在一个线程中导致 CPU 密集型可能阻塞其他请求。

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/7026026.png)

#### 多路复用+多线程worker（nodejs+worker_threads模块)

和单线程多录复用相比，多了一个线程池来搞定CPU密集型任务，处理网络IO还是单线程多路复用（异步）的模式。当然由于还是基于线程，还是会出现线程背景下的一些问题。

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/8149354.png)

#### 协程

基于 Goroutine 的并发方案更像是传统的基于多线程的并发方案，但是 Goroutine 更加轻量（内存栈只有4

KB），调度和资源开销更小（协程切换在用户态，切换只需要几十ns）。

协程大概分为两种：

1. 有栈协程 Go，Lua 等：在用户态实现，有调度器。
2. 无栈协程 Python，js 等 （async/await 为代表的）：通过编译器进行变换，是generator或者回调函数的语法糖。从这点来说无栈协程更像是一种现代编程思维的实现。

最大的区别在于**线程**是有操作系统控制的，由系统调度，是CPU调度的最小单位。多个线程共享所属进程的资源，同时线程也拥有自己的专属资源、拥有自己的栈空间； 

而**协程**的调度完全由用户控制，并且没有内核切换的开销，上下文的切换非常快。它不再被内核调度，而是交给了程序自己。

下图是 Go 的并发模型其中的 G 代表 Goroutine；M 代表 Machine 指的底层并发资源的抽象，一般代表的线程；Processor 代表了 Go 运行时的调度器，它负责将 Goroutines 分配给 Machines 执行。每个 Processor 都有自己的 Goroutine 队列。

在 GMP 模型中，Processor 数量是固定的，通常等于 CPU 的核心数。当一个 Goroutine 需要运行时，它会被添加到一个 Processor 的队列中。然后，Processor 会从队列中取出一个 Goroutine，分配给一个 Machine 执行。当 Machine 完成了 Goroutine 的执行，它会返回到 Processor，等待下一个 Goroutine 。

这种模型允许 Go 程序在多核处理器上并行执行多个 Goroutine，同时避免了频繁的线程切换带来的开销。

M（即线程）的创建不再由用户管理，而是由 Go 运行时根据情况尽量的复用线程。（Go运行时会根据需要创建新的M。例如，当所有的M都被阻塞（例如，等待I/O操作或系统调用），并且还有Goroutine需要运行时，Go运行时会创建一个新的M。当M上的Goroutine执行完毕，M不会立即被销毁，而是会被放入一个空闲列表，以便后续复用。）

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/1336548.png)

##   Go 解决IO/CPU密集型任务的并发

在Go语言中，通过使用goroutine和channel的机制，可以很好地解决CPU密集型任务不阻塞IO任务的问题。
‎
Go语言的调度器（scheduler）使用了一种称为M:N调度的模型。其中，M代表操作系统的线程（OS thread），N代表Go语言的goroutine。调度器会将多个goroutine调度到少量的线程上执行。
‎
当一个goroutine执行一个耗时的CPU密集型任务时，如果该任务没有主动让出CPU，那么调度器就无法将其他goroutine调度到同一个线程上执行，从而导致其他goroutine被阻塞。
‎
为了解决这个问题，Go语言的运行时（runtime）在goroutine的调度中引入了抢占式调度（preemptive scheduling）的机制。在Go语言的运行时中，会根据一定的策略和时间片（time slice）来进行抢占式调度，即在一个goroutine执行一段时间后，会主动让出CPU，让其他goroutine有机会执行。
‎
这样，即使有一个goroutine执行了一个耗时的CPU密集型任务，它也会在一定时间后被调度器抢占，让其他goroutine有机会执行。这样就实现了CPU密集型任务不阻塞IO任务的效果。
‎
需要注意的是，抢占式调度并**不是**在每个CPU指令级别上进行的，而是在Go语言运行时的一些特定点上进行的。这些特定点包括函数调用、通道操作、系统调用等。在这些点上，调度器会检查是否需要进行调度，如果需要，就会将当前goroutine切换出去，让其他goroutine执行。
‎
通过抢占式调度的机制，Go语言能够在处理CPU密集型任务时，保证IO任务的及时响应，提高程序的并发性和响应能力。

## Go 并发实践

#### go 通道的机制

go通道通过在多个协程中建立通讯的方式来共享内存。（创建通讯来共享内存）

先看一下这段代码：

```go
func TestChan(t *testing.T) {
	wg := sync.WaitGroup{}
	ch := make(chan int, 10)
	for i := 0; i < 10; i++ {
		ch <- i
	}
	close(ch)
	wg.Add(4)
	for i := 0; i < 4; i++ {
		go func() {
			for {
				v := <-ch
				fmt.Printf("v: %d\n", v)
			}
			wg.Done()
		}()
	}
	wg.Wait()
}
```

这段代码最后的执行结果是输出0到9后一直输出0。为什么呢？

因为当通道被关闭后，当通道内的值被取尽后继续取值会得到该数据结构的默认值，例如`0`，`{"", false}` 等。

为了避免这样的错误出现，我们可以采用再取值之前判断chan是否能正确取到值来决定是否关闭通道：

```go
go func() {
  for {
    if v, ok := <-ch; ok {
      fmt.Println(v)
    } else {
      wg.Done()
      return
    }
  }
}()
```

正确的使用 channel，使我们更好使用 go 并发机制的基础。

![](https://aeiblog-1301396258.cos.ap-chengdu.myqcloud.com/img/1441035.png)



## 总结

Go 语言使用阻塞写法，底层采用了非阻塞系统调用，通过在运行时中进行转换。这种思想与其标准库完美联动（如标准IO库），使得生态建设更加容易。

